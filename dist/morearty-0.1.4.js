// Generated by uRequire v0.6.18 - template: 'combined' 
// Combined template optimized with RequireJS/r.js v2.1.14 & almond.
(function (global, window){
  'use strict';

var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function() {/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('Util',['require','exports','module'],function (require, exports, module) {
  

'use strict';

var isRequired, findTurningPoint, prepare;
  isRequired = function (spec) {
    return typeof spec === "string" && spec.charAt(0) !== "?";
  };
  findTurningPoint = function (arr, pred) {
    var first = pred(arr[0]);
    for (var i = 1; i < arr.length; i++) {
      if (pred(arr[i]) !== first)
        return i;
    }
    return null;
  };
  prepare = function (arr, splitAt) {
    return arr.slice(splitAt).reverse().concat(arr.slice(0, splitAt));
  };
  var copyOwnProperties = function (source, target) {
    Object.getOwnPropertyNames(source).forEach(function (propKey) {
      var desc = Object.getOwnPropertyDescriptor(source, propKey);
      Object.defineProperty(target, propKey, desc);
    });
    return target;
  };
  return {
    hashcode: function (s) {
      var hash = 0, i, chr, len;
      if (s.length === 0) {
        return hash;
      } else {
        for (i = 0, len = s.length; i < len; i++) {
          chr = s.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        return hash;
      }
    },
    identity: function (x) {
      return x;
    },
    not: function (x) {
      return !x;
    },
    constantly: function (x) {
      return function () {
        return x;
      };
    },
    afterComplete: function (f, cont) {
      var result = f();
      if (result && typeof result.always === "function") {
        result.always(cont);
      } else {
        cont();
      }
    },
    undefinedOrNull: function (x) {
      return x === undefined || x === null;
    },
    startsWith: function (s1, s2) {
      return s1.indexOf(s2) === 0;
    },
    toString: function (x) {
      switch (x) {
      case undefined:
        return "undefined";
      case null:
        return "null";
      default:
        if (typeof x === "string") {
          return "\"" + x + "\"";
        } else if (Array.isArray(x)) {
          return "[" + x.join(", ") + "]";
        } else {
          return x.toString();
        }
      }
    },
    equals: function (x, y) {
      return x === y || x && x.equals && x.equals(y);
    },
    getPropertyValues: function (obj) {
      return Object.keys(obj).map(function (key) {
        return obj[key];
      });
    },
    find: function (arr, pred) {
      for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (pred(value, i, arr)) {
          return value;
        }
      }
      return null;
    },
    findWithIndex: function (arr, pred) {
      for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (pred(value, i, arr)) {
          return {
            index: i,
            value: value
          };
        }
      }
      return null;
    },
    resolveArgs: function (args, var_args) {
      var result = {};
      if (arguments.length > 1) {
        var specs = Array.isArray(var_args) ? var_args : Array.prototype.slice.call(arguments, 1);
        var preparedSpecs, preparedArgs;
        var turningPoint;
        if (isRequired(specs[0]) || !(turningPoint = findTurningPoint(specs, isRequired))) {
          preparedSpecs = specs;
          preparedArgs = args;
        } else {
          var effectiveArgs = Array.isArray(args) ? args : Array.prototype.slice.call(args);
          preparedSpecs = prepare(specs, turningPoint);
          preparedArgs = prepare(effectiveArgs, effectiveArgs.length - (specs.length - turningPoint));
        }
        for (var specIndex = 0, argIndex = 0; specIndex < preparedSpecs.length && argIndex < preparedArgs.length; specIndex++) {
          var spec = preparedSpecs[specIndex], arg = preparedArgs[argIndex];
          if (isRequired(spec)) {
            result[spec] = arg;
            argIndex++;
          } else {
            var name = typeof spec === "function" ? spec(arg) : spec.charAt(0) !== "?" ? spec : spec.substring(1);
            if (name || arg === undefined) {
              result[name] = arg;
              argIndex++;
            }
          }
        }
      }
      return result;
    },
    canRepresentSubpath: function (x) {
      var type = typeof x;
      return type === "string" || type === "number" || Array.isArray(x);
    },
    shallowMerge: function (source, dest) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          dest[prop] = source[prop];
        }
      }
      return dest;
    },
    papply: function (comp, props, override) {
      var self = this;
      var f = function (props2, children) {
        var effectiveChildren = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null;
        if (props2) {
          var effectiveProps = {};
          if (f._props) {
            self.shallowMerge(f._props, effectiveProps);
            self.shallowMerge(props2, effectiveProps);
          } else {
            effectiveProps = props2;
          }
          return comp(effectiveProps, effectiveChildren);
        } else {
          return comp(f._props, effectiveChildren);
        }
      };
      if (comp._props) {
        var newCompProps = {};
        if (override !== false) {
          self.shallowMerge(comp._props, newCompProps);
          self.shallowMerge(props, newCompProps);
        } else {
          self.shallowMerge(props, newCompProps);
          self.shallowMerge(comp._props, newCompProps);
        }
        f._props = newCompProps;
      } else {
        f._props = props;
      }
      return f;
    },
    subclass: function (SubC, SuperC, additionalProperties) {
      var subProto = Object.create(SuperC.prototype);
      copyOwnProperties(SubC.prototype, subProto);
      SubC.prototype = subProto;
      SubC._super = SuperC.prototype;
      if (additionalProperties) {
        this.shallowMerge(additionalProperties, SubC.prototype);
      }
      Object.freeze(SubC.prototype);
    }
  };


});
define('data/Associative',['require','exports','module'],function (require, exports, module) {
  

'use strict';

var throwAbstractMethod, throwPathMustPointToKey, isAssociative;
  throwAbstractMethod = function () {
    throw new Error("Abstract method invocation");
  };
  throwPathMustPointToKey = function () {
    throw new Error("Path must point to a key");
  };
  isAssociative = function (obj) {
    return obj instanceof Associative;
  };
  var createBacktrace, modifyNestedWith;
  createBacktrace = function (path, acc, associative, f) {
    if (path.length === 0) {
      return acc;
    } else {
      if (isAssociative(associative)) {
        var head = path[0];
        var next = associative.get(head);
        acc.unshift({
          associative: associative,
          key: head
        });
        return createBacktrace(path.slice(1), acc, next, f);
      } else {
        return acc;
      }
    }
  };
  modifyNestedWith = function (self, path, f) {
    var backtrace = createBacktrace(path, [], self);
    if (backtrace.length !== path.length) {
      return self;
    } else {
      var head = backtrace[0], associative = head.associative, key = head.key;
      var updated = f(associative, key);
      return updated === associative ? self : backtrace.slice(1).reduce(function (acc, elem) {
        return elem.associative.assoc(elem.key, acc);
      }, updated);
    }
  };
  var Associative = function () {
    if (this.constructor === Associative) {
      throw new Error("Abstract class instatiation");
    }
  };
  Associative.prototype = Object.freeze({
    get: function (key) {
      throwAbstractMethod();
    },
    update: function (key, f) {
      throwAbstractMethod();
    },
    assoc: function (key, value) {
      throwAbstractMethod();
    },
    dissoc: function (key) {
      throwAbstractMethod();
    },
    isAssociative: function (obj) {
      return isAssociative(obj);
    },
    getIn: function (path) {
      if (path.length > 0) {
        var head = path[0], tail = path.slice(1);
        var next = this.get(head);
        if (next !== null) {
          return isAssociative(next) ? next.getIn(tail) : tail.length === 0 ? next : null;
        } else {
          return null;
        }
      } else {
        return this;
      }
    },
    updateIn: function (path, f) {
      if (path.length === 0) {
        throwPathMustPointToKey();
      } else {
        return modifyNestedWith(this, path, function (associative, key) {
          return associative.update(key, f);
        });
      }
    },
    dissocIn: function (path) {
      switch (path.length) {
      case 0:
        throwPathMustPointToKey();
        break;
      case 1:
        return this.dissoc(path[0]);
      default:
        return modifyNestedWith(this, path, function (associative, key) {
          return associative.dissoc(key);
        });
      }
    }
  });
  return Associative;


});
define('data/Map',['require', 'exports', 'module', '../Util', './Associative'], function (require, exports, module, Util, Associative) {
  

'use strict';

var SECTION_SIZE = 4;
  var BUCKET_SIZE = Math.pow(2, SECTION_SIZE);
  var hashFragment = function (shift, hash) {
    return hash >>> shift & BUCKET_SIZE - 1;
  };
  var EMPTY_NODE, NOTHING, isEmpty, isNothing, updateEmpty, update, reduce, equals, isInstance;
  EMPTY_NODE = null;
  NOTHING = {};
  isEmpty = function (node) {
    return !node;
  };
  isNothing = function (x) {
    return x === NOTHING;
  };
  updateEmpty = function (hash, key, f) {
    var value = f();
    return isNothing(value) ? EMPTY_NODE : new LeafNode(hash, key, value);
  };
  update = function (shift, hash, key, f, node) {
    return isEmpty(node) ? updateEmpty(hash, key, f) : node.update(shift, hash, key, f);
  };
  reduce = function (f, acc, node) {
    return isEmpty(node) ? acc : node.reduce(f, acc);
  };
  equals = function (node1, node2, self) {
    if (node1 === node2) {
      return true;
    } else {
      var node1Empty = isEmpty(node1);
      var node2Empty = isEmpty(node2);
      if (node1Empty || node2Empty) {
        return node1Empty && node2Empty;
      } else {
        return node1.equals(node2, self);
      }
    }
  };
  isInstance = function (obj) {
    return obj instanceof Map;
  };
  var mergeLeaves, create1Internal, create2Internal;
  mergeLeaves = function (shift, node1, node2) {
    var hash1Fragment = hashFragment(shift, node1._hash);
    var hash2Fragment = hashFragment(shift, node2._hash);
    return hash1Fragment === hash2Fragment ? create1Internal(hash1Fragment, mergeLeaves(shift + SECTION_SIZE, node1, node2)) : create2Internal(hash1Fragment, node1, hash2Fragment, node2);
  };
  create1Internal = function (hash, node) {
    var children = [];
    children[hash] = node;
    return new InternalNode(1, children);
  };
  create2Internal = function (hash1, node1, hash2, node2) {
    var children = [];
    children[hash1] = node1;
    children[hash2] = node2;
    return new InternalNode(2, children);
  };
  var mergeReduceFunction = function (acc, value, key) {
    var dest = acc.get(key);
    var mergedValue = dest && isInstance(dest) && isInstance(value) ? dest.merge(value) : value;
    return acc.assoc(key, mergedValue);
  };
  var LeafNode, CollisionNode, InternalNode;
  LeafNode = function (hash, key, value) {
    this._hash = hash;
    this._key = key;
    this._value = value;
  };
  LeafNode.prototype = Object.freeze({
    get: function (_shift, _hash, key) {
      return key === this._key ? this._value : null;
    },
    update: function (shift, hash, key, f) {
      var value;
      if (key === this._key) {
        value = f(this._value);
        return isNothing(value) ? EMPTY_NODE : value !== this._value ? new LeafNode(hash, key, value) : this;
      } else {
        value = f();
        var newLeaf = new LeafNode(hash, key, value);
        return isNothing(value) ? this : this._hash === hash ? new CollisionNode(hash, [
          this,
          newLeaf
        ]) : mergeLeaves(shift, this, newLeaf);
      }
    },
    reduce: function (f, acc) {
      return f(acc, this);
    },
    map: function (f) {
      var value = f(this._value);
      return value === this._value ? this : new LeafNode(this._hash, this._key, f(this._value, this._key));
    },
    find: function (pred) {
      return pred(this._value, this._key) ? this._value : null;
    },
    equals: function (leaf, self) {
      if (leaf instanceof LeafNode && this._key === leaf._key) {
        return self.isAssociative(this._value) && self.isAssociative(leaf._value) ? this._value.equals(leaf._value) : this._value === leaf._value;
      } else {
        return false;
      }
    }
  });
  CollisionNode = function (hash, children) {
    this._hash = hash;
    this._children = children;
  };
  CollisionNode.prototype = function () {
    var updateCollisions = function (collisions, hash, key, f) {
      var existing = Util.findWithIndex(collisions, function (leaf) {
          return leaf._key === key;
        });
      var value, newCollisions;
      if (existing) {
        var index = existing.index;
        value = f(existing.value);
        if (value !== existing.value) {
          newCollisions = collisions.slice(0);
          if (isNothing(value)) {
            newCollisions.splice(index, 1);
          } else {
            newCollisions[index] = new LeafNode(hash, key, value);
          }
        } else {
          newCollisions = collisions;
        }
      } else {
        value = f();
        if (!isNothing(value)) {
          newCollisions = collisions.slice(0);
          newCollisions.push(new LeafNode(hash, key, value));
        } else {
          newCollisions = collisions;
        }
      }
      return newCollisions;
    };
    return Object.freeze({
      get: function (_shift, _hash, key) {
        for (var i = 0; i < this._children.length; i++) {
          var node = this._children[i];
          if (node._key === key) {
            return node._value;
          }
        }
        return null;
      },
      update: function (shift, hash, key, f) {
        if (hash === this._hash) {
          var list = updateCollisions(this._children, hash, key, f);
          return list.length > 1 ? new CollisionNode(this._hash, list) : list[0];
        } else {
          var value = f();
          return isNothing(value) ? this : mergeLeaves(shift, this, new LeafNode(hash, key, value));
        }
      },
      reduce: function (f, acc) {
        return this._children.reduce(f, acc);
      },
      map: function (f) {
        return new CollisionNode(this._hash, this._children.map(function (child) {
          return child.map(f);
        }));
      },
      find: function (pred) {
        var child = Util.find(this._children, function (child) {
            return pred(child._value, child._key);
          });
        return child ? child._value : null;
      },
      equals: function (node, self) {
        return node instanceof CollisionNode && this._hash === node._hash && this._children.length === node._children.length && this._children.every(function (child, index) {
          return child.equals(node._children[index], self);
        });
      }
    });
  }();
  InternalNode = function (count, children) {
    this._count = count;
    this._children = children;
  };
  InternalNode.prototype = function () {
    var get, arrayUpdate, arrayRemove, updateInternal;
    get = function (shift, hash, key, node) {
      var fragment = hashFragment(shift, hash);
      var child = node._children[fragment];
      return isEmpty(child) ? null : child.get(shift + SECTION_SIZE, hash, key);
    };
    arrayUpdate = function (arr, index, value) {
      var newArr = arr.slice(0);
      newArr[index] = value;
      return newArr;
    };
    arrayRemove = function (arr, index) {
      var newArr = arr.slice(0);
      delete newArr[index];
      return newArr;
    };
    updateInternal = function (shift, hash, key, f, node) {
      var children = node._children;
      var fragment = hashFragment(shift, hash);
      var child = node._children[fragment];
      var newChild = update(shift + SECTION_SIZE, hash, key, f, child);
      if (isEmpty(child) && !isEmpty(newChild)) {
        return new InternalNode(node._count + 1, arrayUpdate(children, fragment, newChild));
      } else if (!isEmpty(child) && isEmpty(newChild)) {
        var newCount = Math.max(node._count - 1, 0);
        switch (newCount) {
        case 0:
          return EMPTY_NODE;
        case 1:
          var onlyChild = Util.find(children, function (node, i) {
              return node && i !== fragment;
            });
          return onlyChild instanceof InternalNode ? new InternalNode(newCount, arrayRemove(children, fragment)) : onlyChild;
        default:
          return new InternalNode(newCount, arrayRemove(children, fragment));
        }
      } else {
        return newChild === children[fragment] ? node : new InternalNode(node._count, arrayUpdate(children, fragment, newChild));
      }
    };
    return Object.freeze({
      get: function (shift, hash, key) {
        return get(shift, hash, key, this);
      },
      update: function (shift, hash, key, f) {
        return updateInternal(shift, hash, key, f, this);
      },
      reduce: function (f, acc) {
        return this._children.reduce(function (acc2, child) {
          return child ? child instanceof LeafNode ? f(acc2, child) : child.reduce(f, acc2) : acc2;
        }, acc);
      },
      map: function (f) {
        return new InternalNode(this._count, this._children.map(function (child) {
          return child.map(f);
        }));
      },
      find: function (pred) {
        var result = null;
        var nodes = Util.getPropertyValues(this._children);
        for (var i = 0; i < nodes.length; i++) {
          var found = nodes[i].find(pred);
          if (found) {
            result = found;
            break;
          }
        }
        return result;
      },
      equals: function (node, self) {
        return node instanceof InternalNode && this._count === node._count && this._children.every(function (child, index) {
          var otherChild = node._children[index];
          return otherChild && child.equals(otherChild, self);
        });
      }
    });
  }();
  var Map = function (root) {
    this._root = root;
  };
  Map.prototype = Object.freeze({
    fill: function (var_args) {
      var m = this;
      for (var i = 0; i < arguments.length; i += 2) {
        m = m.assoc(arguments[i], arguments[i + 1]);
      }
      return m;
    },
    isEmpty: function () {
      return isEmpty(this._root);
    },
    get: function (key) {
      if (this.isEmpty()) {
        return null;
      } else {
        var result = this._root.get(0, Util.hashcode(key), key);
        return Util.undefinedOrNull(result) ? null : result;
      }
    },
    contains: function (key) {
      return this.get(key) !== null;
    },
    update: function (key, f) {
      var newRoot = update(0, Util.hashcode(key), key, f, this._root);
      return newRoot === this._root ? this : new Map(newRoot);
    },
    updateIfExists: function (key, f) {
      return this.contains(key) ? this.update(key, f) : this;
    },
    assoc: function (key, value) {
      return this.update(key, Util.constantly(value));
    },
    dissoc: function (key) {
      return this.update(key, Util.constantly(NOTHING));
    },
    join: function (otherMap) {
      return this.isEmpty() ? otherMap : otherMap.reduce(function (acc, value, key) {
        return acc.assoc(key, value);
      }, this);
    },
    reduce: function (f, acc) {
      return reduce(function (acc, node) {
        return f(acc, node._value, node._key, this);
      }.bind(this), acc, this._root);
    },
    map: function (f) {
      return this.isEmpty() ? this : new Map(this._root.map(function (value, key) {
        return f(value, key, this);
      }.bind(this)));
    },
    foreach: function (f) {
      reduce(function (_acc, node) {
        f(node._value, node._key, this);
      }.bind(this), null, this._root);
    },
    filter: function (pred) {
      var self = this;
      var result = this.reduce(function (acc, value, key) {
          if (pred(value, key, self)) {
            acc.map = acc.map.assoc(key, value);
          } else {
            acc.someSkipped = true;
          }
          return acc;
        }, {
          map: EMPTY_MAP,
          someSkipped: false
        });
      return result.someSkipped ? result.map : self;
    },
    find: function (pred) {
      return this.isEmpty() ? null : this._root.find(function (value, key) {
        return pred(value, key, this);
      }.bind(this));
    },
    equals: function (otherMap) {
      return this === otherMap || otherMap instanceof Map && equals(this._root, otherMap._root, this);
    },
    size: function () {
      return this.reduce(function (acc) {
        return acc + 1;
      }, 0);
    },
    toString: function () {
      var result = this.reduce(function (acc, value, key) {
          var s = acc === "" ? "" : acc + ", ";
          s += "\"" + key + "\": " + Util.toString(value);
          return s;
        }, "");
      return "{" + result + "}";
    },
    isInstance: function (obj) {
      return isInstance(obj);
    },
    entries: function () {
      return reduce(function (acc, node) {
        acc.push([
          node._key,
          node._value
        ]);
        return acc;
      }, [], this._root);
    },
    keys: function () {
      return reduce(function (acc, node) {
        acc.push(node._key);
        return acc;
      }, [], this._root);
    },
    values: function () {
      return reduce(function (acc, node) {
        acc.push(node._value);
        return acc;
      }, [], this._root);
    },
    fillFromObject: function (obj, f) {
      var effectiveF = f || Util.identity;
      return Object.keys(obj).reduce(function (map, key) {
        return map.assoc(key, effectiveF(obj[key]));
      }, this);
    },
    toObject: function (f) {
      var effectiveF = f || Util.identity;
      return this.reduce(function (obj, value, key) {
        obj[key] = effectiveF(value);
        return obj;
      }, {});
    },
    merge: function (otherMap) {
      return this.isEmpty() || this === otherMap ? otherMap : otherMap.reduce(mergeReduceFunction, this);
    },
    makeSafeKey: function (key) {
      return key.replace(/\./g, "");
    }
  });
  Util.subclass(Map, Associative);
  var EMPTY_MAP = new Map(EMPTY_NODE);
  return EMPTY_MAP;


});
define('data/Vector',['require', 'exports', 'module', '../Util', './Associative'], function (require, exports, module, Util, Associative) {
  

'use strict';

var updateBackingArray, equals, isInstance;
  updateBackingArray = function (vector, f) {
    var newBackingArray = vector._backingArray.slice(0);
    return new Vector(f(newBackingArray));
  };
  equals = function (arr1, arr2, self) {
    if (arr1 === arr2) {
      return true;
    } else {
      if (arr1.length !== arr2.length) {
        return false;
      } else {
        return arr1.every(function (el, index) {
          var other = arr2[index];
          return self.isAssociative(el) && self.isAssociative(other) ? el.equals(other) : el === other;
        });
      }
    }
  };
  isInstance = function (obj) {
    return obj instanceof Vector;
  };
  var Vector = function (backingArray) {
    this._backingArray = backingArray;
  };
  Vector.prototype = Object.freeze({
    fill: function (var_args) {
      if (arguments.length === 0) {
        return this;
      } else {
        var args = Array.prototype.slice.call(arguments);
        return new Vector(this._backingArray.concat(args));
      }
    },
    isEmpty: function () {
      return this._backingArray.length === 0;
    },
    get: function (index) {
      var result = this._backingArray[index];
      return Util.undefinedOrNull(result) ? null : result;
    },
    contains: function (index) {
      return index < this._backingArray.length;
    },
    update: function (index, f) {
      if (this.contains(index)) {
        var originalValue = this.get(index);
        var updatedValue = f(originalValue);
        if (updatedValue === originalValue) {
          return this;
        } else {
          return updateBackingArray(this, function (arr) {
            arr[index] = updatedValue;
            return arr;
          });
        }
      } else {
        var value = f();
        return updateBackingArray(this, function (arr) {
          arr[index] = value;
          return arr;
        });
      }
    },
    updateIfExists: function (index, f) {
      return this.contains(index) ? this.update(index, f) : this;
    },
    assoc: function (index, value) {
      return this.update(index, Util.constantly(value));
    },
    dissoc: function (index) {
      return this.contains(index) ? updateBackingArray(this, function (arr) {
        arr.splice(index, 1);
        return arr;
      }) : this;
    },
    join: function (anotherVector) {
      if (this.isEmpty()) {
        return anotherVector;
      } else if (anotherVector.isEmpty()) {
        return this;
      } else {
        return new Vector(this._backingArray.concat(anotherVector._backingArray));
      }
    },
    reduce: function (f, acc) {
      return this._backingArray.reduce(function (acc, value, index) {
        return f(acc, value, index, this);
      }.bind(this), acc);
    },
    map: function (f) {
      var self = this;
      return self.isEmpty() ? self : updateBackingArray(self, function (arr) {
        return arr.map(function (value, index) {
          return f(value, index, self);
        });
      });
    },
    foreach: function (f) {
      var self = this;
      if (!self.isEmpty()) {
        self._backingArray.forEach(function (value, index) {
          f(value, index, self);
        });
      }
    },
    filter: function (pred) {
      var self = this;
      var result = self.isEmpty() ? self : updateBackingArray(self, function (arr) {
          return arr.filter(function (value, index) {
            return pred(value, index, self);
          });
        });
      return result.size() === self.size() ? self : result;
    },
    find: function (pred) {
      var self = this;
      return Util.find(self._backingArray, function (value, index) {
        return pred(value, index, self);
      });
    },
    equals: function (otherVector) {
      return this === otherVector || otherVector instanceof Vector && equals(this._backingArray, otherVector._backingArray, this);
    },
    size: function () {
      return this._backingArray.length;
    },
    toString: function () {
      return "[" + this._backingArray.map(function (x) {
        return Util.toString(x);
      }).join(", ") + "]";
    },
    isInstance: function (obj) {
      return isInstance(obj);
    },
    insertAt: function (index, value) {
      return updateBackingArray(this, function (arr) {
        if (index < arr.length) {
          arr.splice(index, 0, value);
        } else {
          arr[index] = value;
        }
        return arr;
      });
    },
    prepend: function (value) {
      return updateBackingArray(this, function (arr) {
        arr.unshift(value);
        return arr;
      });
    },
    append: function (value) {
      return updateBackingArray(this, function (arr) {
        arr.push(value);
        return arr;
      });
    },
    fillFromArray: function (arr, f) {
      var effectiveArr = f ? arr.map(f) : arr;
      return this.fill.apply(this, effectiveArr);
    },
    toArray: function (f) {
      return f ? this._backingArray.map(f) : this._backingArray.slice(0);
    }
  });
  Util.subclass(Vector, Associative);
  return new Vector([]);


});
define('data/Util',['require', 'exports', 'module', './Map', './Vector'], function (require, exports, module, Map, Vector) {
  

'use strict';

var toJs, fromJs;
  toJs = function (associative) {
    if (Map.isInstance(associative)) {
      return associative.toObject(toJs);
    } else if (Vector.isInstance(associative)) {
      return associative.toArray(toJs);
    } else {
      return associative;
    }
  };
  fromJs = function (js) {
    if (Array.isArray(js)) {
      return Vector.fillFromArray(js, fromJs);
    } else if (typeof js === "object") {
      return Map.fillFromObject(js, fromJs);
    } else {
      return js;
    }
  };
  return {
    toJs: function (associative) {
      return toJs(associative);
    },
    fromJs: function (js) {
      return fromJs(js);
    },
    groupBy: function (vec, key, f) {
      return vec.reduce(function (map, value) {
        var groupBy = Array.isArray(key) ? value.getIn(key) : value.get(key);
        if (groupBy) {
          return map.assoc(f ? f(groupBy) : groupBy, value);
        } else {
          return map;
        }
      }, Map);
    }
  };


});
define('util/Holder',['require','exports','module'],function (require, exports, module) {
  

'use strict';

var Holder = function (value) {
    this._value = value;
  };
  Holder.prototype = Object.freeze({
    init: function (value) {
      return new Holder(value);
    },
    getValue: function () {
      return this._value;
    },
    setValue: function (newValue) {
      this._value = newValue;
    },
    updateValue: function (update) {
      var oldValue = this._value;
      this._value = update(oldValue);
      return oldValue;
    }
  });
  return new Holder(null);


});
define('Binding',['require', 'exports', 'module', './Util', './data/Map', './data/Vector', './util/Holder'], function (require, exports, module, Util, Map, Vector, Holder) {
  

'use strict';

var copyBinding, getBackingValue, setBackingValue;
  copyBinding = function (binding, backingValueHolder, path) {
    return new Binding(backingValueHolder, binding._regCountHolder, path, binding._listeners, binding._listenerNestingLevelHolder);
  };
  getBackingValue = function (binding) {
    return binding._backingValueHolder.getValue();
  };
  setBackingValue = function (binding, newBackingValue) {
    binding._backingValueHolder.setValue(newBackingValue);
  };
  var EMPTY_PATH, PATH_SEPARATOR, getPathElements, asArrayPath, asStringPath, joinPaths;
  EMPTY_PATH = [];
  PATH_SEPARATOR = ".";
  getPathElements = function (path) {
    return path ? path.split(PATH_SEPARATOR) : [];
  };
  asArrayPath = function (path) {
    return typeof path === "string" ? getPathElements(path) : Util.undefinedOrNull(path) ? [] : path;
  };
  asStringPath = function (path) {
    return typeof path === "string" ? path : path.join(PATH_SEPARATOR);
  };
  joinPaths = function (path1, path2) {
    return path1.concat(path2);
  };
  var getValueAtPath, updateBackingValue, updateValue, removeValue, clear;
  getValueAtPath = function (backingValue, path) {
    return backingValue.getIn(path);
  };
  updateBackingValue = function (binding, f, subpath) {
    var effectivePath = joinPaths(binding._path, subpath);
    var newBackingValue = f(getBackingValue(binding), effectivePath);
    setBackingValue(binding, newBackingValue);
    return effectivePath;
  };
  updateValue = function (binding, update, subpath) {
    return updateBackingValue(binding, function (backingValue, effectivePath) {
      return backingValue.updateIn(effectivePath, update);
    }, subpath);
  };
  removeValue = function (binding, subpath) {
    var effectivePath = joinPaths(binding._path, subpath);
    var newBackingValue = getBackingValue(binding).dissocIn(effectivePath);
    setBackingValue(binding, newBackingValue);
    return effectivePath.slice(0, effectivePath.length - 1);
  };
  clear = function (value) {
    return Map.isInstance(value) ? Map : Vector.isInstance(value) ? Vector : null;
  };
  var ensuringNestingLevel, getRelativePath, notifySamePathListeners, notifyGlobalListeners, isPathAffected, notifyNonGlobalListeners, notifyAllListeners;
  ensuringNestingLevel = function (self, f) {
    self._listenerNestingLevelHolder.updateValue(function (x) {
      return x + 1;
    });
    f(self._listenerNestingLevelHolder.getValue());
    self._listenerNestingLevelHolder.updateValue(function (x) {
      return x - 1;
    });
  };
  getRelativePath = function (listenerPathAsArray, absolutePathAsArray) {
    if (listenerPathAsArray.length === absolutePathAsArray.length) {
      return "";
    } else {
      return asStringPath(absolutePathAsArray.slice(listenerPathAsArray.length));
    }
  };
  notifySamePathListeners = function (samePathListeners, listenerPath, pathAsString, newBackingValue, oldBackingValue) {
    var listenerPathAsArray = asArrayPath(listenerPath);
    var absolutePathAsArray = asArrayPath(pathAsString);
    var newValue = getValueAtPath(newBackingValue, listenerPathAsArray);
    var oldValue = getValueAtPath(oldBackingValue, listenerPathAsArray);
    if (newValue !== oldValue) {
      Util.getPropertyValues(samePathListeners).forEach(function (listenerDescriptor) {
        if (!listenerDescriptor.disabled) {
          listenerDescriptor.cb(newValue, oldValue, pathAsString, getRelativePath(listenerPathAsArray, absolutePathAsArray));
        }
      });
    }
  };
  notifyGlobalListeners = function (listeners, path, newBackingValue, oldBackingValue, listenerNestingLevel) {
    if (listenerNestingLevel < 2) {
      var globalListeners = listeners[""];
      if (globalListeners) {
        notifySamePathListeners(globalListeners, EMPTY_PATH, asStringPath(path), newBackingValue, oldBackingValue);
      }
    }
  };
  isPathAffected = function (listenerPath, changedPath) {
    return Util.startsWith(changedPath, listenerPath) || Util.startsWith(listenerPath, changedPath);
  };
  notifyNonGlobalListeners = function (listeners, path, newBackingValue, oldBackingValue) {
    var pathAsString = asStringPath(path);
    Object.keys(listeners).filter(Util.identity).forEach(function (listenerPath) {
      if (isPathAffected(listenerPath, pathAsString)) {
        notifySamePathListeners(listeners[listenerPath], listenerPath, pathAsString, newBackingValue, oldBackingValue);
      }
    });
  };
  notifyAllListeners = function (self, path, oldBackingValue) {
    ensuringNestingLevel(self, function (nestingLevel) {
      var newBackingValue = getBackingValue(self);
      notifyNonGlobalListeners(self._listeners, path, newBackingValue, oldBackingValue);
      notifyGlobalListeners(self._listeners, path, newBackingValue, oldBackingValue, nestingLevel);
    });
  };
  var findSamePathListeners, setListenerDisabled;
  findSamePathListeners = function (binding, listenerId) {
    return Util.find(Util.getPropertyValues(binding._listeners), function (samePathListeners) {
      return !!samePathListeners[listenerId];
    });
  };
  setListenerDisabled = function (binding, listenerId, disabled) {
    var samePathListeners = findSamePathListeners(binding, listenerId);
    if (samePathListeners) {
      samePathListeners[listenerId].disabled = disabled;
    }
  };
  var Binding = function (backingValueHolder, regCountHolder, path, listeners, listenerNestingLevelHolder) {
    this._backingValueHolder = backingValueHolder;
    this._regCountHolder = regCountHolder || Holder.init(0);
    this._path = path || EMPTY_PATH;
    this._listeners = listeners || {};
    this._listenerNestingLevelHolder = listenerNestingLevelHolder || Holder.init(0);
  };
  Binding.prototype = Object.freeze({
    init: function (backingValue) {
      return new Binding(Holder.init(backingValue));
    },
    withBackingValue: function (newBackingValue) {
      return copyBinding(this, Holder.init(newBackingValue), this._path);
    },
    val: function (subpath) {
      return getValueAtPath(getBackingValue(this), joinPaths(this._path, asArrayPath(subpath)));
    },
    sub: function (subpath) {
      return copyBinding(this, this._backingValueHolder, joinPaths(this._path, asArrayPath(subpath)));
    },
    update: function (subpath, update) {
      var args = Util.resolveArgs(arguments, "?subpath", "update");
      var oldBackingValue = getBackingValue(this);
      var affectedPath = updateValue(this, args.update, asArrayPath(args.subpath));
      notifyAllListeners(this, affectedPath, oldBackingValue);
    },
    assoc: function (subpath, newValue) {
      var args = Util.resolveArgs(arguments, "?subpath", "newValue");
      this.update(args.subpath, Util.constantly(args.newValue));
    },
    dissoc: function (subpath) {
      var oldBackingValue = getBackingValue(this);
      var affectedPath = removeValue(this, asArrayPath(subpath));
      notifyAllListeners(this, affectedPath, oldBackingValue);
    },
    clear: function (subpath) {
      this.update(subpath, function (coll) {
        return clear(coll);
      });
    },
    addListener: function (path, cb) {
      var listenerId = "reg" + this._regCountHolder.updateValue(function (count) {
          return count + 1;
        });
      var pathAsString = asStringPath(joinPaths(this._path, asArrayPath(path)));
      var samePathListeners = this._listeners[pathAsString];
      var listenerDescriptor = {
          cb: cb,
          disabled: false
        };
      if (samePathListeners) {
        samePathListeners[listenerId] = listenerDescriptor;
      } else {
        var listeners = {};
        listeners[listenerId] = listenerDescriptor;
        this._listeners[pathAsString] = listeners;
      }
      return listenerId;
    },
    addGlobalListener: function (cb) {
      return this.addListener(EMPTY_PATH, cb);
    },
    enableListener: function (listenerId) {
      setListenerDisabled(this, listenerId, false);
    },
    disableListener: function (listenerId) {
      setListenerDisabled(this, listenerId, true);
    },
    withDisabledListener: function (listenerId, f) {
      var samePathListeners = findSamePathListeners(this, listenerId);
      if (samePathListeners) {
        var descriptor = samePathListeners[listenerId];
        descriptor.disabled = true;
        Util.afterComplete(f, function () {
          descriptor.disabled = false;
        });
      } else {
        f();
      }
    },
    removeListener: function (listenerId) {
      var samePathListeners = findSamePathListeners(this, listenerId);
      return samePathListeners ? delete samePathListeners[listenerId] : false;
    },
    atomically: function () {
      return new TransactionContext(this, [], []);
    },
    asArrayPath: function (pathAsString) {
      return asArrayPath(pathAsString);
    },
    asStringPath: function (pathAsAnArray) {
      return asStringPath(pathAsAnArray);
    },
    isInstance: function (obj) {
      return obj instanceof Binding;
    }
  });
  var TransactionContext = function (binding, updates, removals) {
    this._binding = binding;
    this._updates = updates;
    this._removals = removals;
    this._committed = false;
  };
  TransactionContext.prototype = function () {
    var addUpdate, addRemoval, hasChanges, filterRedundantPaths, commitSilently;
    addUpdate = function (self, binding, update, subpath) {
      var result = self._updates.slice(0);
      result.push({
        binding: binding,
        update: update,
        subpath: subpath
      });
      return result;
    };
    addRemoval = function (self, binding, subpath) {
      var result = self._removals.slice(0);
      result.push({
        binding: binding,
        subpath: subpath
      });
      return result;
    };
    hasChanges = function (self) {
      return self._updates.length > 0 || self._removals.length > 0;
    };
    filterRedundantPaths = function (affectedPaths) {
      if (affectedPaths.length < 2) {
        return affectedPaths;
      } else {
        var sortedPaths = affectedPaths.sort();
        var previousPath = sortedPaths[0], previousPathAsString = asStringPath(previousPath);
        var result = [previousPath];
        for (var i = 1; i < sortedPaths.length; i++) {
          var currentPath = sortedPaths[i], currentPathAsString = asStringPath(currentPath);
          if (!Util.startsWith(currentPathAsString, previousPathAsString)) {
            result.push(currentPath);
            previousPathAsString = currentPathAsString;
          }
        }
        return result;
      }
    };
    commitSilently = function (self) {
      if (!self._committed) {
        var updatedPaths = self._updates.map(function (o) {
            return updateValue(o.binding, o.update, o.subpath);
          });
        var removedPaths = self._removals.map(function (o) {
            return removeValue(o.binding, o.subpath);
          });
        self._committed = true;
        return updatedPaths.concat(removedPaths);
      } else {
        throw new Error("Transaction already committed");
      }
    };
    return Object.freeze({
      update: function (subpath, binding, update) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding", "update");
        var effectiveBinding = args.binding || this._binding;
        var updates = addUpdate(this, effectiveBinding, args.update, asArrayPath(args.subpath));
        return new TransactionContext(effectiveBinding, updates, this._removals);
      },
      assoc: function (subpath, binding, newValue) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding", "newValue");
        return this.update(args.subpath, args.binding, Util.constantly(args.newValue));
      },
      dissoc: function (subpath, binding) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding");
        var effectiveBinding = args.binding || this._binding;
        var removals = addRemoval(this, effectiveBinding, asArrayPath(args.subpath));
        return new TransactionContext(effectiveBinding, this._updates, removals);
      },
      clear: function (subpath, binding) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding");
        var effectiveBinding = args.binding || this._binding;
        var updates = addUpdate(this, effectiveBinding, function (value) {
            return clear(value);
          }, asArrayPath(args.subpath));
        return new TransactionContext(effectiveBinding, updates, this._removals);
      },
      commit: function (notifyListeners) {
        if (hasChanges(this)) {
          var binding = this._binding;
          var oldBackingValue = getBackingValue(binding);
          var affectedPaths = commitSilently(this);
          var newBackingValue = getBackingValue(binding);
          if (notifyListeners !== false) {
            if (newBackingValue !== oldBackingValue) {
              var filteredPaths = filterRedundantPaths(affectedPaths);
              ensuringNestingLevel(binding, function (nestingLevel) {
                var listeners = binding._listeners;
                filteredPaths.forEach(function (path) {
                  notifyNonGlobalListeners(listeners, path, newBackingValue, oldBackingValue);
                });
                notifyGlobalListeners(listeners, filteredPaths[0], newBackingValue, oldBackingValue, nestingLevel);
              }.bind(binding));
              return affectedPaths;
            } else {
              return [];
            }
          } else {
            return affectedPaths;
          }
        } else {
          return [];
        }
      }
    });
  }();
  return new Binding(Holder.init(Map));


});
define('History',['require', 'exports', 'module', './data/Map', './data/Vector'], function (require, exports, module, Map, Vector) {
  

'use strict';

var initHistory, clearHistory, destroyHistory, listenForChanges, revertToStep, revert;
  initHistory = function (historyBinding) {
    historyBinding.assoc(Map.fill("listenerId", null, "undo", Vector, "redo", Vector));
  };
  clearHistory = function (historyBinding) {
    historyBinding.atomically().assoc("undo", Vector).assoc("redo", Vector).commit();
  };
  destroyHistory = function (historyBinding) {
    var listenerId = historyBinding.val("listenerId");
    historyBinding.removeListener(listenerId);
    historyBinding.assoc(null);
  };
  listenForChanges = function (binding, historyBinding) {
    var listenerId = binding.addListener([], function (newValue, oldValue, absolutePath, relativePath) {
        historyBinding.atomically().update(function (history) {
          return history.update("undo", function (undo) {
            var pathAsArray = binding.asArrayPath(relativePath);
            return undo.prepend(Map.fillFromObject({
              newValue: pathAsArray.length ? newValue.getIn(pathAsArray) : newValue,
              oldValue: pathAsArray.length ? oldValue.getIn(pathAsArray) : oldValue,
              path: relativePath
            }));
          }).assoc("redo", Vector);
        }).commit(false);
      });
    historyBinding.atomically().assoc("listenerId", listenerId).commit(false);
  };
  revertToStep = function (path, value, listenerId, dataBinding) {
    dataBinding.withDisabledListener(listenerId, function () {
      dataBinding.assoc(path, value);
    });
  };
  revert = function (dataBinding, fromBinding, toBinding, listenerId, valueProperty) {
    var from = fromBinding.val();
    if (!from.isEmpty()) {
      var step = from.get(0);
      fromBinding.atomically().dissoc(0).update(toBinding, function (to) {
        return to.prepend(step);
      }).commit(false);
      revertToStep(step.get("path"), step.get(valueProperty), listenerId, dataBinding);
      return true;
    } else {
      return false;
    }
  };
  return {
    init: function (dataBinding, historyBinding) {
      initHistory(historyBinding);
      listenForChanges(dataBinding, historyBinding);
    },
    clear: function (historyBinding) {
      clearHistory(historyBinding);
    },
    destroy: function (historyBinding) {
      destroyHistory(historyBinding);
    },
    hasUndo: function (historyBinding) {
      var undo = historyBinding.val("undo");
      return !!undo && !undo.isEmpty();
    },
    hasRedo: function (historyBinding) {
      var redo = historyBinding.val("redo");
      return !!redo && !redo.isEmpty();
    },
    undo: function (dataBinding, historyBinding) {
      var listenerId = historyBinding.val("listenerId");
      var undoBinding = historyBinding.sub("undo");
      var redoBinding = historyBinding.sub("redo");
      return revert(dataBinding, undoBinding, redoBinding, listenerId, "oldValue");
    },
    redo: function (dataBinding, historyBinding) {
      var listenerId = historyBinding.val("listenerId");
      var undoBinding = historyBinding.sub("undo");
      var redoBinding = historyBinding.sub("redo");
      return revert(dataBinding, redoBinding, undoBinding, listenerId, "newValue");
    }
  };


});
define('util/Callback',['require', 'exports', 'module', '../Util'], function (require, exports, module, Util) {
  

'use strict';

return {
    assoc: function (binding, subpath, f) {
      var args = Util.resolveArgs(arguments, "binding", function (x) {
          return Util.canRepresentSubpath(x) ? "subpath" : null;
        }, "?f");
      return function (event) {
        var value = event.target.value;
        binding.assoc(args.subpath, args.f ? args.f(value) : value);
        return false;
      };
    },
    dissoc: function (binding, subpath, pred) {
      var args = Util.resolveArgs(arguments, "binding", function (x) {
          return Util.canRepresentSubpath(x) ? "subpath" : null;
        }, "?pred");
      return function (event) {
        var value = event.target.value;
        if (!args.pred || args.pred(value)) {
          binding.dissoc(args.subpath);
        }
        return false;
      };
    },
    onKey: function (cb, keyCode, shiftKey, ctrlKey) {
      return function (event) {
        if (event.keyCode === keyCode && event.shiftKey === shiftKey && event.ctrlKey === ctrlKey) {
          cb(event);
          return false;
        } else {
          return true;
        }
      };
    },
    onEnter: function (cb) {
      return this.onKey(cb, 13, false, false);
    },
    onEscape: function (cb) {
      return this.onKey(cb, 27, false, false);
    }
  };


});
define('Morearty',['require', 'exports', 'module', './Util', './data/Map', './data/Vector', './data/Util', './Binding', './History', './util/Callback'], function (require, exports, module, Util, Map, Vector, DataUtil, Binding, History, Callback) {
  

'use strict';

var Context = function (React, initialState, configuration) {
    this.React = React;
    this._previousState = Map;
    this._currentStateBinding = Binding.init(initialState);
    this._configuration = configuration;
    this._fullUpdateQueued = false;
    this._fullUpdateInProgress = false;
  };
  Context.prototype = function () {
    var getState, bindingChanged, stateChanged;
    getState = function (context, comp, key) {
      var state = comp.props[context._configuration.statePropertyName];
      return key ? state[key] : state;
    };
    bindingChanged = function (binding, previousState) {
      var currentValue = binding.val();
      var previousValue = binding.withBackingValue(previousState).val();
      return currentValue !== previousValue;
    };
    stateChanged = function (context, state) {
      var previousState = context._previousState;
      if (Binding.isInstance(state)) {
        return bindingChanged(state, previousState);
      } else {
        var bindings = Util.getPropertyValues(state);
        return !!Util.find(bindings, function (binding) {
          return bindingChanged(binding, previousState);
        });
      }
    };
    return Object.freeze({
      Util: Util,
      Data: {
        Map: Map,
        Vector: Vector,
        Util: DataUtil
      },
      Binding: Binding,
      History: History,
      Callback: Callback,
      state: function () {
        return this._currentStateBinding;
      },
      currentState: function () {
        return this.state().val();
      },
      previousState: function () {
        return this._previousState;
      },
      init: function (rootComp) {
        var self = this;
        var requestAnimationFrameEnabled = self._configuration.requestAnimationFrameEnabled;
        var requestAnimationFrame = window && window.requestAnimationFrame;
        var render = function (newValue, oldValue) {
          self._previousState = oldValue;
          if (self._fullUpdateQueued) {
            self._fullUpdateInProgress = true;
            rootComp.forceUpdate(function () {
              self._fullUpdateQueued = false;
              self._fullUpdateInProgress = false;
            });
          } else {
            rootComp.forceUpdate();
          }
        };
        self._currentStateBinding.addGlobalListener(function (newValue, oldValue) {
          if (requestAnimationFrameEnabled && requestAnimationFrame) {
            requestAnimationFrame(render.bind(self, newValue, oldValue), null);
          } else {
            render(newValue, oldValue);
          }
        });
      },
      createClass: function (spec) {
        var context = this;
        var shouldComponentUpdate = function () {
          if (context._fullUpdateInProgress) {
            return true;
          } else {
            var state = getState(context, this);
            return !state || stateChanged(context, state);
          }
        };
        if (!spec.shouldComponentUpdate) {
          spec.shouldComponentUpdate = shouldComponentUpdate;
        }
        spec.shouldComponentUpdateSuper = shouldComponentUpdate;
        spec.getState = function (key) {
          return getState(context, this, key);
        };
        return context.React.createClass(spec);
      },
      queueFullUpdate: function () {
        this._fullUpdateQueued = true;
      }
    });
  }();
  return {
    createContext: function (React, initialState, configuration) {
      var state = Map.isAssociative(initialState) ? initialState : DataUtil.fromJs(initialState);
      var conf = configuration || {};
      return new Context(React, state, {
        statePropertyName: conf.statePropertyName || "state",
        requestAnimationFrameEnabled: conf.requestAnimationFrameEnabled || false
      });
    }
  };


});
define('Main',['require', 'exports', 'module', './Util', './data/Map', './data/Vector', './data/Util', './Binding', './History', './util/Callback', './Morearty'], function (require, exports, module) {
  var __umodule__ = (function (require, exports, module) {
  

'use strict';

return {
    Util: require("./Util"),
    Data: {
      Map: require("./data/Map"),
      Vector: require("./data/Vector"),
      Util: require("./data/Util")
    },
    Binding: require("./Binding"),
    History: require("./History"),
    Callback: require("./util/Callback"),
    createContext: require("./Morearty").createContext
  };


}).call(this, require, exports, module);
var __old__morearty0 = window['Morearty'];
window['Morearty'] = __umodule__;

__umodule__.noConflict = function () {
  window['Morearty'] = __old__morearty0;
return __umodule__;
};
return __umodule__;
});
    return require('Main');
  };
if (__isAMD) {
  return define(bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory();
    } else {
        return bundleFactory();
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))