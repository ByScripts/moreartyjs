// Generated by uRequire v0.6.19 - template: 'combined' 
// Combined template optimized with RequireJS/r.js v2.1.14 & almond.
(function (global, window){
  'use strict';

var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

  var __nodeRequire = (__isNode ? require :
      function(dep){
        throw new Error("uRequire detected missing dependency: '" + dep + "' - in a non-nodejs runtime. All it's binding variables were 'undefined'.")
      });
var bundleFactory = function() {/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('Util',['require','exports','module'],function (require, exports, module) {
  

'use strict';

var isRequired, findTurningPoint, prepare;
  isRequired = function (spec) {
    return typeof spec === "string" && spec.charAt(0) !== "?";
  };
  findTurningPoint = function (arr, pred) {
    var first = pred(arr[0]);
    for (var i = 1; i < arr.length; i++) {
      if (pred(arr[i]) !== first)
        return i;
    }
    return null;
  };
  prepare = function (arr, splitAt) {
    return arr.slice(splitAt).reverse().concat(arr.slice(0, splitAt));
  };
  return {
    identity: function (x) {
      return x;
    },
    not: function (x) {
      return !x;
    },
    constantly: function (x) {
      return function () {
        return x;
      };
    },
    afterComplete: function (f, cont) {
      var result = f();
      if (result && typeof result.always === "function") {
        result.always(cont);
      } else {
        cont();
      }
    },
    undefinedOrNull: function (x) {
      return x === undefined || x === null;
    },
    startsWith: function (s1, s2) {
      return s1.indexOf(s2) === 0;
    },
    toString: function (x) {
      switch (x) {
      case undefined:
        return "undefined";
      case null:
        return "null";
      default:
        if (typeof x === "string") {
          return "\"" + x + "\"";
        } else if (Array.isArray(x)) {
          return "[" + x.join(", ") + "]";
        } else {
          return x.toString();
        }
      }
    },
    equals: function (x, y) {
      return x === y || x && x.equals && x.equals(y);
    },
    getPropertyValues: function (obj) {
      return Object.keys(obj).map(function (key) {
        return obj[key];
      });
    },
    find: function (arr, pred) {
      for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        if (pred(value, i, arr)) {
          return value;
        }
      }
      return null;
    },
    resolveArgs: function (args, var_args) {
      var result = {};
      if (arguments.length > 1) {
        var specs = Array.isArray(var_args) ? var_args : Array.prototype.slice.call(arguments, 1);
        var preparedSpecs, preparedArgs;
        var turningPoint;
        if (isRequired(specs[0]) || !(turningPoint = findTurningPoint(specs, isRequired))) {
          preparedSpecs = specs;
          preparedArgs = args;
        } else {
          var effectiveArgs = Array.isArray(args) ? args : Array.prototype.slice.call(args);
          preparedSpecs = prepare(specs, turningPoint);
          preparedArgs = prepare(effectiveArgs, effectiveArgs.length - (specs.length - turningPoint));
        }
        for (var specIndex = 0, argIndex = 0; specIndex < preparedSpecs.length && argIndex < preparedArgs.length; specIndex++) {
          var spec = preparedSpecs[specIndex], arg = preparedArgs[argIndex];
          if (isRequired(spec)) {
            result[spec] = arg;
            argIndex++;
          } else {
            var name = typeof spec === "function" ? spec(arg) : spec.charAt(0) !== "?" ? spec : spec.substring(1);
            if (name || arg === undefined) {
              result[name] = arg;
              argIndex++;
            }
          }
        }
      }
      return result;
    },
    canRepresentSubpath: function (x) {
      var type = typeof x;
      return type === "string" || type === "number" || Array.isArray(x);
    },
    shallowMerge: function (source, dest) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          dest[prop] = source[prop];
        }
      }
      return dest;
    },
    papply: function (comp, props, override) {
      var self = this;
      var f = function (props2, children) {
        var effectiveChildren = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null;
        if (props2) {
          var effectiveProps = {};
          if (f._props) {
            self.shallowMerge(f._props, effectiveProps);
            self.shallowMerge(props2, effectiveProps);
          } else {
            effectiveProps = props2;
          }
          return comp(effectiveProps, effectiveChildren);
        } else {
          return comp(f._props, effectiveChildren);
        }
      };
      if (comp._props) {
        var newCompProps = {};
        if (override !== false) {
          self.shallowMerge(comp._props, newCompProps);
          self.shallowMerge(props, newCompProps);
        } else {
          self.shallowMerge(props, newCompProps);
          self.shallowMerge(comp._props, newCompProps);
        }
        f._props = newCompProps;
      } else {
        f._props = props;
      }
      return f;
    }
  };


});
define('Dyn',['require','exports','module'],function (require, exports, module) {
  

'use strict';

var callbacks = {};
  var modules = {};
  return {
    onRegisterModule: function (name, cb) {
      callbacks[name] = callbacks[name] || [];
      callbacks[name].push(cb);
    },
    registerModule: function (name, module) {
      modules[name] = module;
      if (callbacks[name]) {
        callbacks[name].forEach(function (cb) {
          cb(module);
          delete callbacks[name];
        });
      }
    }
  };


});
define('util/Holder',['require','exports','module'],function (require, exports, module) {
  

'use strict';

var Holder = function (value) {
    this._value = value;
  };
  Holder.prototype = Object.freeze({
    init: function (value) {
      return new Holder(value);
    },
    getValue: function () {
      return this._value;
    },
    setValue: function (newValue) {
      this._value = newValue;
    },
    updateValue: function (update) {
      var oldValue = this._value;
      this._value = update(oldValue);
      return oldValue;
    }
  });
  return new Holder(null);


});
define('Binding',['require', 'exports', 'module', './Dyn', './Util', './util/Holder'], function (require, exports, module, Dyn, Util, Holder) {
  

'use strict';

var Imm = null;
  Dyn.onRegisterModule("Immutable", function (module) {
    Imm = module;
  });
  var copyBinding, getBackingValue, setBackingValue;
  copyBinding = function (binding, backingValueHolder, path) {
    return new Binding(backingValueHolder, binding._regCountHolder, path, binding._listeners, binding._listenerNestingLevelHolder);
  };
  getBackingValue = function (binding) {
    return binding._backingValueHolder.getValue();
  };
  setBackingValue = function (binding, newBackingValue) {
    binding._backingValueHolder.setValue(newBackingValue);
  };
  var EMPTY_PATH, PATH_SEPARATOR, getPathElements, asArrayPath, asStringPath, joinPaths;
  EMPTY_PATH = [];
  PATH_SEPARATOR = ".";
  getPathElements = function (path) {
    return path ? path.split(PATH_SEPARATOR).map(function (s) {
      return isNaN(s) ? s : +s;
    }) : [];
  };
  asArrayPath = function (path) {
    return typeof path === "string" ? getPathElements(path) : Util.undefinedOrNull(path) ? [] : path;
  };
  asStringPath = function (path) {
    return typeof path === "string" ? path : path.join(PATH_SEPARATOR);
  };
  joinPaths = function (path1, path2) {
    return path1.concat(path2);
  };
  var throwPathMustPointToKey, getValueAtPath, updateBackingValue, updateValue, unsetValue, clear;
  throwPathMustPointToKey = function () {
    throw new Error("Path must point to a key");
  };
  getValueAtPath = function (backingValue, path) {
    return path.length > 0 ? backingValue.getIn(path) : backingValue;
  };
  updateBackingValue = function (binding, f, subpath) {
    var effectivePath = joinPaths(binding._path, subpath);
    var newBackingValue = f(getBackingValue(binding), effectivePath);
    setBackingValue(binding, newBackingValue);
    return effectivePath;
  };
  updateValue = function (binding, update, subpath) {
    return updateBackingValue(binding, function (backingValue, effectivePath) {
      var setOrUpdate = function (coll, key) {
        return coll.has(key) ? coll.update(key, update) : coll.set(key, update());
      };
      var len = effectivePath.length;
      switch (len) {
      case 0:
        throwPathMustPointToKey();
        break;
      case 1:
        return setOrUpdate(backingValue, effectivePath[0]);
      default:
        var pathTo = effectivePath.slice(0, len - 1);
        var key = effectivePath[len - 1];
        return backingValue.updateIn(pathTo, function (coll) {
          return setOrUpdate(coll, key);
        });
      }
    }, subpath);
  };
  unsetValue = function (binding, subpath) {
    var effectivePath = joinPaths(binding._path, subpath);
    var backingValue = getBackingValue(binding);
    var newBackingValue;
    var len = effectivePath.length;
    var pathTo = effectivePath.slice(0, len - 1);
    var deleteValue = function (coll, key) {
      if (coll instanceof Imm.Vector) {
        return coll.splice(key, 1).toVector();
      } else {
        return coll.delete(key);
      }
    };
    switch (len) {
    case 0:
      throwPathMustPointToKey();
      break;
    case 1:
      newBackingValue = deleteValue(backingValue, effectivePath[0]);
      break;
    default:
      var key = effectivePath[len - 1];
      newBackingValue = backingValue.has(pathTo[0]) && backingValue.updateIn(pathTo, function (coll) {
        return deleteValue(coll, key);
      }) || backingValue;
    }
    setBackingValue(binding, newBackingValue);
    return pathTo;
  };
  clear = function (value) {
    return value ? value.clear() : value;
  };
  var ensuringNestingLevel, getRelativePath, notifySamePathListeners, notifyGlobalListeners, isPathAffected, notifyNonGlobalListeners, notifyAllListeners;
  ensuringNestingLevel = function (self, f) {
    self._listenerNestingLevelHolder.updateValue(function (x) {
      return x + 1;
    });
    f(self._listenerNestingLevelHolder.getValue());
    self._listenerNestingLevelHolder.updateValue(function (x) {
      return x - 1;
    });
  };
  getRelativePath = function (listenerPathAsArray, absolutePathAsArray) {
    if (listenerPathAsArray.length === absolutePathAsArray.length) {
      return "";
    } else {
      return asStringPath(absolutePathAsArray.slice(listenerPathAsArray.length));
    }
  };
  notifySamePathListeners = function (samePathListeners, listenerPath, pathAsString, newBackingValue, oldBackingValue) {
    var listenerPathAsArray = asArrayPath(listenerPath);
    var absolutePathAsArray = asArrayPath(pathAsString);
    var newValue = getValueAtPath(newBackingValue, listenerPathAsArray);
    var oldValue = getValueAtPath(oldBackingValue, listenerPathAsArray);
    if (newValue !== oldValue) {
      Util.getPropertyValues(samePathListeners).forEach(function (listenerDescriptor) {
        if (!listenerDescriptor.disabled) {
          listenerDescriptor.cb(newValue, oldValue, pathAsString, getRelativePath(listenerPathAsArray, absolutePathAsArray));
        }
      });
    }
  };
  notifyGlobalListeners = function (listeners, path, newBackingValue, oldBackingValue, listenerNestingLevel) {
    if (listenerNestingLevel < 2) {
      var globalListeners = listeners[""];
      if (globalListeners) {
        notifySamePathListeners(globalListeners, EMPTY_PATH, asStringPath(path), newBackingValue, oldBackingValue);
      }
    }
  };
  isPathAffected = function (listenerPath, changedPath) {
    return Util.startsWith(changedPath, listenerPath) || Util.startsWith(listenerPath, changedPath);
  };
  notifyNonGlobalListeners = function (listeners, path, newBackingValue, oldBackingValue) {
    var pathAsString = asStringPath(path);
    Object.keys(listeners).filter(Util.identity).forEach(function (listenerPath) {
      if (isPathAffected(listenerPath, pathAsString)) {
        notifySamePathListeners(listeners[listenerPath], listenerPath, pathAsString, newBackingValue, oldBackingValue);
      }
    });
  };
  notifyAllListeners = function (self, path, oldBackingValue) {
    ensuringNestingLevel(self, function (nestingLevel) {
      var newBackingValue = getBackingValue(self);
      notifyNonGlobalListeners(self._listeners, path, newBackingValue, oldBackingValue);
      notifyGlobalListeners(self._listeners, path, newBackingValue, oldBackingValue, nestingLevel);
    });
  };
  var findSamePathListeners, setListenerDisabled;
  findSamePathListeners = function (binding, listenerId) {
    return Util.find(Util.getPropertyValues(binding._listeners), function (samePathListeners) {
      return !!samePathListeners[listenerId];
    });
  };
  setListenerDisabled = function (binding, listenerId, disabled) {
    var samePathListeners = findSamePathListeners(binding, listenerId);
    if (samePathListeners) {
      samePathListeners[listenerId].disabled = disabled;
    }
  };
  var Binding = function (backingValueHolder, regCountHolder, path, listeners, listenerNestingLevelHolder) {
    this._backingValueHolder = backingValueHolder;
    this._regCountHolder = regCountHolder || Holder.init(0);
    this._path = path || EMPTY_PATH;
    this._listeners = listeners || {};
    this._listenerNestingLevelHolder = listenerNestingLevelHolder || Holder.init(0);
  };
  Binding.prototype = Object.freeze({
    init: function (backingValue) {
      return new Binding(Holder.init(backingValue));
    },
    withBackingValue: function (newBackingValue) {
      return copyBinding(this, Holder.init(newBackingValue), this._path);
    },
    setBackingValue: function (newBackingValue, notifyListeners) {
      var oldBackingValue = getBackingValue(this);
      this._backingValueHolder.setValue(newBackingValue);
      if (notifyListeners !== false) {
        notifyAllListeners(this, EMPTY_PATH, oldBackingValue);
      }
    },
    val: function (subpath) {
      return getValueAtPath(getBackingValue(this), joinPaths(this._path, asArrayPath(subpath)));
    },
    sub: function (subpath) {
      return copyBinding(this, this._backingValueHolder, joinPaths(this._path, asArrayPath(subpath)));
    },
    update: function (subpath, update) {
      var args = Util.resolveArgs(arguments, "?subpath", "update");
      var oldBackingValue = getBackingValue(this);
      var affectedPath = updateValue(this, args.update, asArrayPath(args.subpath));
      notifyAllListeners(this, affectedPath, oldBackingValue);
    },
    set: function (subpath, newValue) {
      var args = Util.resolveArgs(arguments, "?subpath", "newValue");
      this.update(args.subpath, Util.constantly(args.newValue));
    },
    delete: function (subpath) {
      var oldBackingValue = getBackingValue(this);
      var affectedPath = unsetValue(this, asArrayPath(subpath));
      notifyAllListeners(this, affectedPath, oldBackingValue);
    },
    merge: function (subpath, preserve, newValue) {
      var args = Util.resolveArgs(arguments, function (x) {
          return Util.canRepresentSubpath(x) ? "subpath" : null;
        }, "?preserve", "newValue");
      this.update(args.subpath, function (value) {
        var effectiveNewValue = args.newValue;
        if (Util.undefinedOrNull(value)) {
          return effectiveNewValue;
        } else {
          if (value instanceof Imm.Sequence && effectiveNewValue instanceof Imm.Sequence) {
            return args.preserve ? effectiveNewValue.mergeDeep(value) : value.mergeDeep(effectiveNewValue);
          } else {
            return args.preserve ? value : effectiveNewValue;
          }
        }
      });
    },
    clear: function (subpath) {
      var effectiveSubpath = asArrayPath(subpath);
      if (getBackingValue(this).getIn(effectiveSubpath))
        this.update(effectiveSubpath, function (coll) {
          return clear(coll);
        });
    },
    addListener: function (path, cb) {
      var listenerId = "reg" + this._regCountHolder.updateValue(function (count) {
          return count + 1;
        });
      var pathAsString = asStringPath(joinPaths(this._path, asArrayPath(path)));
      var samePathListeners = this._listeners[pathAsString];
      var listenerDescriptor = {
          cb: cb,
          disabled: false
        };
      if (samePathListeners) {
        samePathListeners[listenerId] = listenerDescriptor;
      } else {
        var listeners = {};
        listeners[listenerId] = listenerDescriptor;
        this._listeners[pathAsString] = listeners;
      }
      return listenerId;
    },
    addGlobalListener: function (cb) {
      return this.addListener(EMPTY_PATH, cb);
    },
    enableListener: function (listenerId) {
      setListenerDisabled(this, listenerId, false);
    },
    disableListener: function (listenerId) {
      setListenerDisabled(this, listenerId, true);
    },
    withDisabledListener: function (listenerId, f) {
      var samePathListeners = findSamePathListeners(this, listenerId);
      if (samePathListeners) {
        var descriptor = samePathListeners[listenerId];
        descriptor.disabled = true;
        Util.afterComplete(f, function () {
          descriptor.disabled = false;
        });
      } else {
        f();
      }
    },
    removeListener: function (listenerId) {
      var samePathListeners = findSamePathListeners(this, listenerId);
      return samePathListeners ? delete samePathListeners[listenerId] : false;
    },
    atomically: function () {
      return new TransactionContext(this, [], []);
    },
    asArrayPath: function (pathAsString) {
      return asArrayPath(pathAsString);
    },
    asStringPath: function (pathAsAnArray) {
      return asStringPath(pathAsAnArray);
    },
    isInstance: function (obj) {
      return obj instanceof Binding;
    }
  });
  var TransactionContext = function (binding, updates, removals) {
    this._binding = binding;
    this._updates = updates;
    this._removals = removals;
    this._committed = false;
  };
  TransactionContext.prototype = function () {
    var addUpdate, addRemoval, hasChanges, filterRedundantPaths, commitSilently;
    addUpdate = function (self, binding, update, subpath) {
      var result = self._updates.slice(0);
      result.push({
        binding: binding,
        update: update,
        subpath: subpath
      });
      return result;
    };
    addRemoval = function (self, binding, subpath) {
      var result = self._removals.slice(0);
      result.push({
        binding: binding,
        subpath: subpath
      });
      return result;
    };
    hasChanges = function (self) {
      return self._updates.length > 0 || self._removals.length > 0;
    };
    filterRedundantPaths = function (affectedPaths) {
      if (affectedPaths.length < 2) {
        return affectedPaths;
      } else {
        var sortedPaths = affectedPaths.sort();
        var previousPath = sortedPaths[0], previousPathAsString = asStringPath(previousPath);
        var result = [previousPath];
        for (var i = 1; i < sortedPaths.length; i++) {
          var currentPath = sortedPaths[i], currentPathAsString = asStringPath(currentPath);
          if (!Util.startsWith(currentPathAsString, previousPathAsString)) {
            result.push(currentPath);
            previousPathAsString = currentPathAsString;
          }
        }
        return result;
      }
    };
    commitSilently = function (self) {
      if (!self._committed) {
        var updatedPaths = self._updates.map(function (o) {
            return updateValue(o.binding, o.update, o.subpath);
          });
        var removedPaths = self._removals.map(function (o) {
            return unsetValue(o.binding, o.subpath);
          });
        self._committed = true;
        return updatedPaths.concat(removedPaths);
      } else {
        throw new Error("Transaction already committed");
      }
    };
    return Object.freeze({
      update: function (subpath, binding, update) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding", "update");
        var effectiveBinding = args.binding || this._binding;
        var updates = addUpdate(this, effectiveBinding, args.update, asArrayPath(args.subpath));
        return new TransactionContext(effectiveBinding, updates, this._removals);
      },
      set: function (subpath, binding, newValue) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding", "newValue");
        return this.update(args.subpath, args.binding, Util.constantly(args.newValue));
      },
      delete: function (subpath, binding) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding");
        var effectiveBinding = args.binding || this._binding;
        var removals = addRemoval(this, effectiveBinding, asArrayPath(args.subpath));
        return new TransactionContext(effectiveBinding, this._updates, removals);
      },
      merge: function (subpath, preserve, binding, newValue) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, function (x) {
            return typeof x === "boolean" ? "preserve" : null;
          }, "?binding", "newValue");
        return this.update(args.subpath, args.binding, function (value) {
          var effectiveNewValue = args.newValue;
          if (Util.undefinedOrNull(value)) {
            return newValue;
          } else {
            if (value instanceof Imm.Sequence && effectiveNewValue instanceof Imm.Sequence) {
              return args.preserve ? effectiveNewValue.mergeDeep(value) : value.mergeDeep(effectiveNewValue);
            } else {
              return args.preserve ? value : effectiveNewValue;
            }
          }
        });
      },
      clear: function (subpath, binding) {
        var args = Util.resolveArgs(arguments, function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?binding");
        var effectiveBinding = args.binding || this._binding;
        var updates = addUpdate(this, effectiveBinding, function (value) {
            return clear(value);
          }, asArrayPath(args.subpath));
        return new TransactionContext(effectiveBinding, updates, this._removals);
      },
      commit: function (notifyListeners) {
        if (hasChanges(this)) {
          var binding = this._binding;
          var oldBackingValue = getBackingValue(binding);
          var affectedPaths = commitSilently(this);
          var newBackingValue = getBackingValue(binding);
          if (notifyListeners !== false) {
            if (newBackingValue !== oldBackingValue) {
              var filteredPaths = filterRedundantPaths(affectedPaths);
              ensuringNestingLevel(binding, function (nestingLevel) {
                var listeners = binding._listeners;
                filteredPaths.forEach(function (path) {
                  notifyNonGlobalListeners(listeners, path, newBackingValue, oldBackingValue);
                });
                notifyGlobalListeners(listeners, filteredPaths[0], newBackingValue, oldBackingValue, nestingLevel);
              }.bind(binding));
              return affectedPaths;
            } else {
              return [];
            }
          } else {
            return affectedPaths;
          }
        } else {
          return [];
        }
      }
    });
  }();
  return new Binding(Holder.init(null));


});
define('History',['require', 'exports', 'module', './Dyn'], function (require, exports, module, Dyn) {
  

'use strict';

var Imm = null;
  Dyn.onRegisterModule("Immutable", function (module) {
    Imm = module;
  });
  var initHistory, clearHistory, destroyHistory, listenForChanges, revertToStep, revert;
  initHistory = function (historyBinding) {
    historyBinding.set(Imm.fromJS({
      listenerId: null,
      undo: [],
      redo: []
    }));
  };
  clearHistory = function (historyBinding) {
    historyBinding.atomically().set("undo", Imm.Vector.empty()).set("redo", Imm.Vector.empty()).commit();
  };
  destroyHistory = function (historyBinding) {
    var listenerId = historyBinding.val("listenerId");
    historyBinding.removeListener(listenerId);
    historyBinding.set(null);
  };
  listenForChanges = function (binding, historyBinding) {
    var listenerId = binding.addListener([], function (newValue, oldValue, absolutePath, relativePath) {
        historyBinding.atomically().update(function (history) {
          return history.update("undo", function (undo) {
            var pathAsArray = binding.asArrayPath(relativePath);
            return undo.unshift(Imm.Map({
              newValue: pathAsArray.length ? newValue.getIn(pathAsArray) : newValue,
              oldValue: pathAsArray.length ? oldValue.getIn(pathAsArray) : oldValue,
              path: relativePath
            }));
          }).set("redo", Imm.Vector.empty());
        }).commit(false);
      });
    historyBinding.atomically().set("listenerId", listenerId).commit(false);
  };
  revertToStep = function (path, value, listenerId, dataBinding) {
    dataBinding.withDisabledListener(listenerId, function () {
      dataBinding.set(path, value);
    });
  };
  revert = function (dataBinding, fromBinding, toBinding, listenerId, valueProperty) {
    var from = fromBinding.val();
    if (from.length > 0) {
      var step = from.get(0);
      fromBinding.atomically().delete(0).update(toBinding, function (to) {
        return to.unshift(step);
      }).commit(false);
      revertToStep(step.get("path"), step.get(valueProperty), listenerId, dataBinding);
      return true;
    } else {
      return false;
    }
  };
  return {
    init: function (dataBinding, historyBinding) {
      initHistory(historyBinding);
      listenForChanges(dataBinding, historyBinding);
    },
    clear: function (historyBinding) {
      clearHistory(historyBinding);
    },
    destroy: function (historyBinding) {
      destroyHistory(historyBinding);
    },
    hasUndo: function (historyBinding) {
      var undo = historyBinding.val("undo");
      return !!undo && undo.length > 0;
    },
    hasRedo: function (historyBinding) {
      var redo = historyBinding.val("redo");
      return !!redo && redo.length > 0;
    },
    undo: function (dataBinding, historyBinding) {
      var listenerId = historyBinding.val("listenerId");
      var undoBinding = historyBinding.sub("undo");
      var redoBinding = historyBinding.sub("redo");
      return revert(dataBinding, undoBinding, redoBinding, listenerId, "oldValue");
    },
    redo: function (dataBinding, historyBinding) {
      var listenerId = historyBinding.val("listenerId");
      var undoBinding = historyBinding.sub("undo");
      var redoBinding = historyBinding.sub("redo");
      return revert(dataBinding, redoBinding, undoBinding, listenerId, "newValue");
    }
  };


});
define('util/Callback',['require', 'exports', 'module', '../Util'], function (require, exports, module, Util) {
  

'use strict';

return {
    set: function (binding, subpath, f) {
      var args = Util.resolveArgs(arguments, "binding", function (x) {
          return Util.canRepresentSubpath(x) ? "subpath" : null;
        }, "?f");
      return function (event) {
        var value = event.target.value;
        binding.set(args.subpath, args.f ? args.f(value) : value);
        return false;
      };
    },
    delete: function (binding, subpath, pred) {
      var args = Util.resolveArgs(arguments, "binding", function (x) {
          return Util.canRepresentSubpath(x) ? "subpath" : null;
        }, "?pred");
      return function (event) {
        var value = event.target.value;
        if (!args.pred || args.pred(value)) {
          binding.delete(args.subpath);
        }
        return false;
      };
    },
    onKey: function (cb, key, shiftKey, ctrlKey) {
      var effectiveShiftKey = shiftKey || false;
      var effectiveCtrlKey = ctrlKey || false;
      return function (event) {
        var keyMatched = typeof key === "string" ? event.key === key : Util.find(key, function (k) {
            return k === event.key;
          });
        if (keyMatched && event.shiftKey === effectiveShiftKey && event.ctrlKey === effectiveCtrlKey) {
          cb(event);
          return false;
        } else {
          return true;
        }
      };
    },
    onEnter: function (cb) {
      return this.onKey(cb, "Enter");
    },
    onEscape: function (cb) {
      return this.onKey(cb, "Escape");
    }
  };


});
define('DOM',['require', 'exports', 'module', './Dyn'], function (require, exports, module, Dyn) {
  

'use strict';

var exports = {};
  var React;
  Dyn.onRegisterModule("React", function (module) {
    React = module;
    var _ = React.DOM;
    exports.input = wrapComponent(_.input, "input");
    exports.textarea = wrapComponent(_.textarea, "textarea");
    exports.otion = wrapComponent(_.option, "option");
    Object.freeze(exports);
  });
  var wrapComponent = function (comp, displayName) {
    return React.createClass({
      getDisplayName: function () {
        return displayName;
      },
      getInitialState: function () {
        return { value: this.props.value };
      },
      onChange: function (event) {
        var handler = this.props.onChange;
        if (handler) {
          var result = handler(event);
          this.setState({ value: event.target.value });
          return result;
        }
      },
      componentWillReceiveProps: function (newProps) {
        this.setState({ value: newProps.value });
      },
      render: function () {
        return this.transferPropsTo(comp({
          value: this.state.value,
          onChange: this.onChange,
          children: this.props.children
        }));
      }
    });
  };
  return exports;


});
define('Morearty',['require', 'exports', 'module', './Dyn', './Util', './Binding', './History', './util/Callback', './DOM'], function (require, exports, module, Dyn, Util, Binding, History, Callback, DOM) {
  

'use strict';

var MERGE_STRATEGY = Object.freeze({
      OVERWRITE: "overwrite",
      OVERWRITE_EMPTY: "overwrite-empty",
      MERGE_PRESERVE: "merge-preserve",
      MERGE_REPLACE: "merge-replace"
    });
  var Context = function (React, Immutable, initialState, configuration) {
    this.React = React;
    this.Immutable = Immutable;
    this.Imm = Immutable;
    this._initialState = initialState;
    this._previousState = null;
    this._currentStateBinding = Binding.init(initialState);
    this._configuration = configuration;
    this._fullUpdateQueued = false;
    this._fullUpdateInProgress = false;
  };
  Context.prototype = function () {
    var getState, bindingChanged, stateChanged;
    getState = function (context, comp, key) {
      var state = comp.props[context._configuration.statePropertyName];
      return key ? state[key] : state;
    };
    bindingChanged = function (binding, previousState) {
      var currentValue = binding.val();
      var previousValue = previousState ? binding.withBackingValue(previousState).val() : null;
      return currentValue !== previousValue;
    };
    stateChanged = function (context, state) {
      var previousState = context._previousState;
      if (Binding.isInstance(state)) {
        return bindingChanged(state, previousState);
      } else {
        var bindings = Util.getPropertyValues(state);
        return !!Util.find(bindings, function (binding) {
          return bindingChanged(binding, previousState);
        });
      }
    };
    var enrichShouldComponentUpdate, enrichComponentWillMount;
    enrichShouldComponentUpdate = function (context, spec) {
      var shouldComponentUpdate = function () {
        if (context._fullUpdateInProgress) {
          return true;
        } else {
          var state = getState(context, this);
          return !state || stateChanged(context, state);
        }
      };
      if (!spec.shouldComponentUpdate) {
        spec.shouldComponentUpdate = shouldComponentUpdate;
      }
      spec.shouldComponentUpdateSuper = shouldComponentUpdate;
    };
    enrichComponentWillMount = function (context, spec) {
      var existingComponentWillMount = spec.componentWillMount;
      if (typeof spec.getDefaultState === "function") {
        spec.componentWillMount = function () {
          var defaultState = spec.getDefaultState();
          if (defaultState) {
            var state = getState(context, this);
            var mergeStrategy = typeof spec.getMergeStrategy === "function" ? spec.getMergeStrategy() : MERGE_STRATEGY.MERGE_PRESERVE;
            var tx = state.atomically();
            if (typeof mergeStrategy === "function") {
              tx = tx.update(function (currentState) {
                return mergeStrategy(currentState, defaultState);
              });
            } else {
              switch (mergeStrategy) {
              case MERGE_STRATEGY.OVERWRITE:
                tx = tx.set(defaultState);
                break;
              case MERGE_STRATEGY.OVERWRITE_EMPTY:
                tx = tx.update(function (currentState) {
                  var empty = Util.undefinedOrNull(currentState) || currentState instanceof context.Imm.Sequence && currentState.count() === 0;
                  return empty ? defaultState : currentState;
                });
                break;
              case MERGE_STRATEGY.MERGE_PRESERVE:
                tx = tx.merge(true, defaultState);
                break;
              case MERGE_STRATEGY.MERGE_REPLACE:
                tx = tx.merge(false, defaultState);
                break;
              default:
                throw new Error("Invalid merge strategy: " + mergeStrategy);
              }
            }
            tx.commit(false);
          }
          if (existingComponentWillMount) {
            existingComponentWillMount.call(this);
          }
        };
      }
    };
    return Object.freeze({
      Util: Util,
      Binding: Binding,
      History: History,
      Callback: Callback,
      MergeStrategy: MERGE_STRATEGY,
      DOM: DOM,
      state: function () {
        return this._currentStateBinding;
      },
      currentState: function () {
        return this.state().val();
      },
      previousState: function () {
        return this._previousState;
      },
      resetState: function (notifyListeners) {
        this._currentStateBinding.setBackingValue(this._initialState, notifyListeners !== false);
      },
      replaceState: function (newState, notifyListeners) {
        this._currentStateBinding.setBackingValue(newState, notifyListeners);
      },
      changed: function (binding, subpath, compare) {
        var args = Util.resolveArgs(arguments, "binding", function (x) {
            return Util.canRepresentSubpath(x) ? "subpath" : null;
          }, "?compare");
        var currentValue = args.binding.val(args.subpath);
        var previousValue = args.binding.withBackingValue(this._previousState).val(args.subpath);
        return args.compare ? !args.compare(currentValue, previousValue) : currentValue !== previousValue;
      },
      init: function (rootComp) {
        var self = this;
        var requestAnimationFrameEnabled = self._configuration.requestAnimationFrameEnabled;
        var requestAnimationFrame = window && window.requestAnimationFrame;
        var render = function (newValue, oldValue) {
          self._previousState = oldValue;
          if (self._fullUpdateQueued) {
            self._fullUpdateInProgress = true;
            rootComp.forceUpdate(function () {
              self._fullUpdateQueued = false;
              self._fullUpdateInProgress = false;
            });
          } else {
            rootComp.forceUpdate();
          }
        };
        self._currentStateBinding.addGlobalListener(function (newValue, oldValue) {
          if (requestAnimationFrameEnabled && requestAnimationFrame) {
            requestAnimationFrame(render.bind(self, newValue, oldValue), null);
          } else {
            render(newValue, oldValue);
          }
        });
      },
      createClass: function (spec) {
        var context = this;
        enrichShouldComponentUpdate.call(this, context, spec);
        enrichComponentWillMount.call(this, context, spec);
        spec.getState = function (key) {
          return getState(context, this, key);
        };
        spec.getPreviousState = function (key) {
          return getState(context, this, key).withBackingValue(context._previousState).val();
        };
        return context.React.createClass(spec);
      },
      queueFullUpdate: function () {
        this._fullUpdateQueued = true;
      }
    });
  }();
  return {
    createContext: function (React, Immutable, initialState, configuration) {
      Dyn.registerModule("React", React);
      Dyn.registerModule("Immutable", Immutable);
      var Map = Immutable.Map;
      var state = initialState instanceof Map ? initialState : Immutable.fromJS(initialState);
      var conf = configuration || {};
      return new Context(React, Immutable, state, {
        statePropertyName: conf.statePropertyName || "state",
        requestAnimationFrameEnabled: conf.requestAnimationFrameEnabled || false
      });
    }
  };


});
define('Main',['require', 'exports', 'module', './Util', './Morearty'], function (require, exports, module) {
  var __umodule__ = (function (require, exports, module) {
  

'use strict';

return {
    Util: require("./Util"),
    createContext: require("./Morearty").createContext
  };


}).call(this, require, exports, module);
var __old__morearty0 = window['Morearty'];
window['Morearty'] = __umodule__;

__umodule__.noConflict = function () {
  window['Morearty'] = __old__morearty0;
return __umodule__;
};
return __umodule__;
});
    return require('Main');
  };
if (__isAMD) {
  return define(bundleFactory);
} else {
    if (__isNode) {
        return module.exports = bundleFactory();
    } else {
        return bundleFactory();
    }
}
}).call(this, (typeof exports === 'object' ? global : window),
              (typeof exports === 'object' ? global : window))