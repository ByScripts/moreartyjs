<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Morearty.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Morearty.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @name Morearty
 * @namespace
 * @classdesc Morearty main module. Exposes [createContext]{@link Morearty.createContext} function.
 */
var Imm      = require('immutable');
var Util     = require('./Util');
var Binding  = require('./Binding');
var History  = require('./History');
var Callback = require('./util/Callback');
var DOM      = require('./DOM');

var MERGE_STRATEGY = Object.freeze({
  OVERWRITE: 'overwrite',
  OVERWRITE_EMPTY: 'overwrite-empty',
  MERGE_PRESERVE: 'merge-preserve',
  MERGE_REPLACE: 'merge-replace'
});

var getBinding, bindingChanged, stateChanged;

getBinding = function (context, comp, key) {
  if (context) {
    var binding = comp.props[context._configuration.bindingPropertyName];
    return key ? binding[key] : binding;
  } else {
    throw new Error('Context is missing.');
  }
};

bindingChanged = function (binding, context) {
  return (context._stateChanged &amp;&amp; binding.isChanged(context._previousState)) ||
    (context._metaChanged &amp;&amp; context._metaBinding.sub(binding.getPath()).isChanged(context._previousMetaState));
};

stateChanged = function (context, state) {
  if (state instanceof Binding) {
    return bindingChanged(state, context);
  } else {
    var bindings = Util.getPropertyValues(state);
    return !!Util.find(bindings, function (binding) {
      return binding &amp;&amp; bindingChanged(binding, context);
    });
  }
};

var merge = function (mergeStrategy, defaultState, stateBinding) {
  var tx = stateBinding.atomically();

  if (typeof mergeStrategy === 'function') {
    tx = tx.update(function (currentState) {
      return mergeStrategy(currentState, defaultState);
    });
  } else {
    switch (mergeStrategy) {
      case MERGE_STRATEGY.OVERWRITE:
        tx = tx.set(defaultState);
        break;
      case MERGE_STRATEGY.OVERWRITE_EMPTY:
        tx = tx.update(function (currentState) {
          var empty = Util.undefinedOrNull(currentState) ||
            (currentState instanceof Imm.Iterable &amp;&amp; currentState.count() === 0);
          return empty ? defaultState : currentState;
        });
        break;
      case MERGE_STRATEGY.MERGE_PRESERVE:
        tx = tx.merge(true, defaultState);
        break;
      case MERGE_STRATEGY.MERGE_REPLACE:
        tx = tx.merge(false, defaultState);
        break;
      default:
        throw new Error('Invalid merge strategy: ' + mergeStrategy);
    }
  }

  tx.commit({ notify: false });
};

/** Morearty context constructor.
 * @param {Immutable.Map} initialState initial state
 * @param {Immutable.Map} initialMetaState initial meta-state
 * @param {Object} configuration configuration
 * @public
 * @class Context
 * @classdesc Represents Morearty context.
 * &lt;p>Exposed modules:
 * &lt;ul>
 *   &lt;li>[Util]{@link Util};&lt;/li>
 *   &lt;li>[Binding]{@link Binding};&lt;/li>
 *   &lt;li>[History]{@link History};&lt;/li>
 *   &lt;li>[Callback]{@link Callback};&lt;/li>
 *   &lt;li>[DOM]{@link DOM}.&lt;/li>
 * &lt;/ul> */
var Context = function (initialState, initialMetaState, configuration) {
  /** @private */
  this._initialMetaState = initialMetaState;
  /** @private */
  this._previousMetaState = null;
  /** @private */
  this._metaBinding = Binding.init(initialMetaState);
  /** @private */
  this._metaChanged = false;

  /** @private */
  this._initialState = initialState;
  /** @protected
   * @ignore */
  this._previousState = null;
  /** @private */
  this._stateBinding = Binding.init(initialState, this._metaBinding);
  /** @private */
  this._stateChanged = false;

  /** @private */
  this._configuration = configuration;

  /** @private */
  this._fullUpdateQueued = false;
  /** @protected
   * @ignore */
  this._fullUpdateInProgress = false;
};

Context.prototype = Object.freeze( /** @lends Context.prototype */ {
  /** Get state binding.
   * @return {Binding} state binding
   * @see Binding */
  getBinding: function () {
    return this._stateBinding;
  },

  /** Get meta binding.
   * @return {Binding} meta binding
   * @see Binding */
  getMetaBinding: function () {
    return this._metaBinding;
  },

  /** Get current state.
   * @return {Immutable.Map} current state */
  getCurrentState: function () {
    return this.getBinding().get();
  },

  /** Get previous state (before last render).
   * @return {Immutable.Map} previous state */
  getPreviousState: function () {
    return this._previousState;
  },

  /** Get current meta state.
   * @returns {Immutable.Map} current meta state */
  getCurrentMeta: function () {
    var metaBinding = this.getMetaBinding();
    return metaBinding ? metaBinding.get() : undefined;
  },

  /** Get previous meta state (before last render).
   * @return {Immutable.Map} previous meta state */
  getPreviousMeta: function () {
    return this._previousMetaState;
  },

  /** Revert to initial state.
   * @param {String|Array} [subpath] subpath as a dot-separated string or an array of strings and numbers
   * @param {Object} [options] options object, supported options are:
   * &lt;ul>
   *   &lt;li>notify - should listeners be notified, true by default, set to false to disable notification;&lt;/li>
   *   &lt;li>resetMeta - should meta state be reverted, true by default, set to false to disable.&lt;/li>
   * &lt;/ul> */
  resetState: function (subpath, options) {
    var args = Util.resolveArgs(
      arguments,
      function (x) { return Util.canRepresentSubpath(x) ? 'subpath' : null; }, '?options'
    );

    var pathAsArray = args.subpath ? Binding.asArrayPath(args.subpath) : [];

    var tx = this.getBinding().atomically();
    tx.set(pathAsArray, this._initialState.getIn(pathAsArray));

    var effectiveOptions = args.options || {};
    if (effectiveOptions.resetMeta !== false) {
      tx.set(this.getMetaBinding(), pathAsArray, this._initialMetaState.getIn(pathAsArray));
    }

    tx.commit({ notify: effectiveOptions.notify });
  },

  /** Replace whole state with new value.
   * @param {Immutable.Map} newState new state
   * @param {Immutable.Map} [newMetaState] new meta state
   * @param {Object} [options] options object, supported options are:
   * &lt;ul>
   *   &lt;li>notify - should listeners be notified, true by default, set to false to disable notification.&lt;/li>
   * &lt;/ul> */
  replaceState: function (newState, newMetaState, options) {
    var args = Util.resolveArgs(
      arguments,
      'newState', function (x) { return x instanceof Imm.Map ? 'newMetaState' : null; }, '?options'
    );

    var effectiveOptions = args.options || {};

    var tx = this.getBinding().atomically();
    tx.set(newState);

    if (args.newMetaState) tx.set(this.getMetaBinding(), args.newMetaState);

    tx.commit({ notify: effectiveOptions.notify });
  },

  /** Check if binding value was changed on last re-render.
   * @param {Binding} binding binding
   * @param {String|Array} [subpath] subpath as a dot-separated string or an array of strings and numbers
   * @param {Function} [compare] compare function, '===' by default */
  isChanged: function (binding, subpath, compare) {
    var args = Util.resolveArgs(
      arguments,
      'binding', function (x) { return Util.canRepresentSubpath(x) ? 'subpath' : null; }, '?compare'
    );

    return !args.binding.sub(args.subpath).isChanged(this._previousState, args.compare || Imm.is);
  },

  /** Initialize rendering.
   * @param {Object} rootComp root application component */
  init: function (rootComp) {
    var self = this;
    var requestAnimationFrameEnabled = self._configuration.requestAnimationFrameEnabled;
    var requestAnimationFrame = window &amp;&amp; window.requestAnimationFrame;

    var render = function (changes, stateChanged, metaChanged) {
      if (rootComp.isMounted()) {

        self._stateChanged = stateChanged;
        if (stateChanged) {
          self._currentState = self._stateBinding.get();
          self._previousState = changes.getPreviousValue();
        }

        self._metaChanged = metaChanged;
        if (metaChanged) {
          self._currentMetaState = self._metaBinding.get();
          self._previousMetaState = changes.getPreviousMeta();
        }

        try {
          if (self._fullUpdateQueued) {
            self._fullUpdateInProgress = true;
            rootComp.forceUpdate(function () {
              self._fullUpdateQueued = false;
              self._fullUpdateInProgress = false;
            });
          } else {
            rootComp.forceUpdate();
          }
        } catch (e) {
          if (self._configuration.stopOnRenderError) {
            throw e;
          } else {
            console.error('Morearty: skipping render error', e);
          }
        }
      }
    };

    self._stateBinding.addGlobalListener(function (changes) {
      var stateChanged = changes.isValueChanged(), metaChanged = changes.isMetaChanged();

      if (stateChanged || metaChanged) {
        if (requestAnimationFrameEnabled &amp;&amp; requestAnimationFrame) {
          requestAnimationFrame(render.bind(null, changes, stateChanged, metaChanged), null);
        } else {
          render(changes, stateChanged, metaChanged);
        }
      }

    });
  },

  /** Queue full update on next render. */
  queueFullUpdate: function () {
    this._fullUpdateQueued = true;
  }

});

module.exports = {

  /** Binding module.
   * @memberOf Morearty
   * @see Binding */
  Binding: Binding,

  /** History module.
   * @memberOf Morearty
   * @see History */
  History: History,

  /** Util module.
   * @memberOf Morearty
   * @see Util */
  Util: Util,

  /** Callback module.
   * @memberOf Morearty
   * @see Callback */
  Callback: Callback,

  /** DOM module.
   * @memberOf Morearty
   * @see DOM */
  DOM: DOM,

  /** Merge strategy.
   * &lt;p>Describes how existing state should be merged with component's default state on mount. Predefined strategies:
   * &lt;ul>
   *   &lt;li>OVERWRITE - overwrite current state with default state;&lt;/li>
   *   &lt;li>OVERWRITE_EMPTY - overwrite current state with default state only if current state is null or empty collection;&lt;/li>
   *   &lt;li>MERGE_PRESERVE - deep merge current state into default state;&lt;/li>
   *   &lt;li>MERGE_REPLACE - deep merge default state into current state.&lt;/li>
   * &lt;/ul> */
  MergeStrategy: MERGE_STRATEGY,

  /** Morearty mixin.
   * @memberOf Morearty
   * @namespace
   * @classdesc Mixin */
  Mixin: {
    contextTypes: { morearty: function () {} },

    /** Get Morearty context.
     * @returns {Context} */
    getMoreartyContext: function () {
      return this.context.morearty;
    },

    /** Get component state binding. Returns binding specified in component's binding attribute.
     * @param {String} [name] binding name (can only be used with multi-binding state)
     * @return {Binding|Object} component state binding */
    getBinding: function (name) {
      return getBinding(this.getMoreartyContext(), this, name);
    },

    /** Get default component state binding. Use this to get component's binding.
     * &lt;p>Default binding is single binding for single-binding components or
     * binding with key 'default' for multi-binding components.
     * This method allows smooth migration from single to multi-binding components, e.g. you start with:
     * &lt;pre>&lt;code>{ binding: foo }&lt;/code>&lt;/pre>
     * or
     * &lt;pre>&lt;code>{ binding: { default: foo } }&lt;/code>&lt;/pre>
     * or even
     * &lt;pre>&lt;code>{ binding: { any: foo } }&lt;/code>&lt;/pre>
     * and add more bindings later:
     * &lt;pre>&lt;code>{ binding: { default: foo, aux: auxiliary } }&lt;/code>&lt;/pre>
     * This way code changes stay minimal.
     * @return {Binding} default component state binding */
    getDefaultBinding: function () {
      var context = this.getMoreartyContext();
      var binding = getBinding(context, this);
      if (binding instanceof Binding) {
        return binding;
      } else if (typeof binding === 'object') {
        var keys = Object.keys(binding);
        return keys.length === 1 ? binding[keys[0]] : binding['default'];
      }
    },

    /** Get component previous state value.
     * @param {String} [name] binding name (can only be used with multi-binding state)
     * @return {Binding} previous component state value */
    getPreviousState: function (name) {
      var context = this.getMoreartyContext();
      return getBinding(context, this, name).withBackingValue(context._previousState).get();
    },

    componentWillMount: function () {
      if (typeof this.getDefaultState === 'function') {
        var context = this.getMoreartyContext();
        var defaultState = this.getDefaultState();
        if (defaultState) {
          var binding = getBinding(context, this);
          var mergeStrategy =
              typeof this.getMergeStrategy === 'function' ? this.getMergeStrategy() : MERGE_STRATEGY.MERGE_PRESERVE;

          var immutableInstance = defaultState instanceof Imm.Iterable;

          if (binding instanceof Binding) {
            var effectiveDefaultState = immutableInstance ? defaultState : defaultState['default'];
            merge.call(context, mergeStrategy, effectiveDefaultState, binding);
          } else {
            var keys = Object.keys(binding);
            var defaultKey = keys.length === 1 ? keys[0] : 'default';
            var effectiveMergeStrategy = typeof mergeStrategy === 'string' ? mergeStrategy : mergeStrategy[defaultKey];

            if (immutableInstance) {
              merge.call(context, effectiveMergeStrategy, defaultState, binding[defaultKey]);
            } else {
              keys.forEach(function (key) {
                if (defaultState[key]) {
                  merge.call(context, effectiveMergeStrategy, defaultState[key], binding[key]);
                }
              });
            }
          }
        }
      }
    },

    shouldComponentUpdate: function (nextProps, nextState) {
      var self = this;
      var context = self.getMoreartyContext();
      var shouldComponentUpdate = function () {
        if (context._fullUpdateInProgress) {
          return true;
        } else {
          var binding = getBinding(context, self);
          return !binding || stateChanged(context, binding);
        }
      };

      var shouldComponentUpdateOverride = self.shouldComponentUpdateOverride;
      return shouldComponentUpdateOverride ?
        shouldComponentUpdateOverride(shouldComponentUpdate, nextProps, nextState) :
        shouldComponentUpdate();
    }
  },

  /** Create Morearty context.
   * @param {Immutable.Map|Object} initialState initial state
   * @param {Immutable.Map|Object} initialMetaState initial meta-state
   * @param {Object} [options] Morearty configuration. Supported parameters:
   * &lt;ul>
   *   &lt;li>bindingPropertyName - name of the property holding component's binding, 'binding' by default;&lt;/li>
   *   &lt;li>requestAnimationFrameEnabled - enable rendering in requestAnimationFrame, false by default;&lt;/li>
   *   &lt;li>stopOnRenderError - stop on errors during render, false by default.&lt;/li>
   * &lt;/ul>
   * @return {Context}
   * @memberOf Morearty */
  createContext: function (initialState, initialMetaState, options) {
    var ensureImmutable = function (state) {
      return state instanceof Imm.Iterable ? state : Imm.fromJS(state);
    };

    var state = ensureImmutable(initialState);
    var metaState = initialMetaState ? ensureImmutable(initialMetaState) : Imm.Map();
    var effectiveOptions = options || {};
    return new Context(state, metaState, {
      bindingPropertyName: effectiveOptions.bindingPropertyName || 'binding',
      requestAnimationFrameEnabled: effectiveOptions.requestAnimationFrameEnabled || false,
      stopOnRenderError: effectiveOptions.stopOnRenderError || false
    });
  }

};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Binding.html">Binding</a></li><li><a href="ChangesDescriptor.html">ChangesDescriptor</a></li><li><a href="Context.html">Context</a></li><li><a href="Holder.html">Holder</a></li><li><a href="TransactionContext.html">TransactionContext</a></li></ul><h3>Namespaces</h3><ul><li><a href="Callback.html">Callback</a></li><li><a href="DOM.html">DOM</a></li><li><a href="History.html">History</a></li><li><a href="Morearty.html">Morearty</a></li><li><a href="Morearty.Mixin.html">Mixin</a></li><li><a href="Util.html">Util</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Sun Nov 02 2014 15:24:19 GMT+0300 (FET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
